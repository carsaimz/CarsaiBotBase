const { getAudioUrl } = require('google-tts-api');
const fs = require('fs');
const https = require('https');
const path = require('path');
const logger = require('./logger');

class TTSService {
    constructor() {
        this.cacheDir = path.join(__dirname, '../assets/audios');
        this.initCacheDir();
    }

    initCacheDir() {
        if (!fs.existsSync(this.cacheDir)) {
            fs.mkdirSync(this.cacheDir, { recursive: true });
        }
    }

    async textToSpeech(text, lang = 'pt-BR') {
        try {
            // Validar entrada
            if (!text || text.trim().length === 0) {
                throw new Error('Texto vazio fornecido para TTS');
            }

            if (text.length > 200) {
                throw new Error('Texto muito longo (m√°ximo 200 caracteres)');
            }

            // Criar nome de arquivo √∫nico
            const crypto = require('crypto');
            const hash = crypto.createHash('md5').update(`${text}-${lang}`).digest('hex');
            const filename = `tts_${hash}.mp3`;
            const filepath = path.join(this.cacheDir, filename);

            // Verificar cache
            if (fs.existsSync(filepath)) {
                logger.debug(`TTS: √Åudio encontrado em cache - ${filename}`);
                return filepath;
            }

            logger.debug(`TTS: Gerando novo √°udio - "${text.substring(0, 30)}..."`);

            // Obter URL do √°udio
            const audioUrl = getAudioUrl(text, {
                lang: lang,
                slow: false,
                host: 'https://translate.google.com',
            });

            // Baixar √°udio
            await this.downloadFile(audioUrl, filepath);
            
            return filepath;

        } catch (error) {
            logger.error(`Erro no TTS: ${error.message}`);
            throw error;
        }
    }

    downloadFile(url, filepath) {
        return new Promise((resolve, reject) => {
            const file = fs.createWriteStream(filepath);
            
            https.get(url, (response) => {
                // Verificar resposta
                if (response.statusCode !== 200) {
                    file.close();
                    fs.unlink(filepath, () => {});
                    reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
                    return;
                }

                // Verificar tipo de conte√∫do
                const contentType = response.headers['content-type'];
                if (!contentType || !contentType.includes('audio')) {
                    file.close();
                    fs.unlink(filepath, () => {});
                    reject(new Error('Resposta n√£o √© um √°udio v√°lido'));
                    return;
                }

                // Baixar arquivo
                response.pipe(file);
                
                file.on('finish', () => {
                    file.close();
                    logger.debug(`TTS: √Åudio salvo em ${filepath}`);
                    resolve();
                });
                
            }).on('error', (err) => {
                file.close();
                fs.unlink(filepath, () => {});
                reject(err);
            });

            // Timeout de 30 segundos
            response.on('socket', (socket) => {
                socket.setTimeout(30000);
                socket.on('timeout', () => {
                    response.destroy();
                    reject(new Error('Timeout ao baixar √°udio'));
                });
            });
        });
    }

    async sendAsVoice(sock, jid, text, lang = 'pt-BR') {
        try {
            const audioPath = await this.textToSpeech(text, lang);
            
            // Enviar como nota de voz
            await sock.sendMessage(jid, {
                audio: fs.readFileSync(audioPath),
                mimetype: 'audio/mpeg',
                ptt: true, // Nota de voz
                fileName: 'carsai_tts.mp3'
            });

            logger.debug(`TTS: √Åudio enviado para ${jid}`);
            
            // Limpar arquivo ap√≥s 5 minutos
            setTimeout(() => {
                try {
                    fs.unlinkSync(audioPath);
                } catch (e) {
                    // Ignorar erros na limpeza
                }
            }, 300000);

        } catch (error) {
            logger.error(`Erro ao enviar TTS: ${error.message}`);
            throw error;
        }
    }

    // Comando TTS pronto para uso
    async handleTTSCommand(sock, jid, args) {
        if (!args || args.length === 0) {
            return await sock.sendMessage(jid, {
                text: "‚ùå Por favor, forne√ßa um texto. Exemplo: `!tts Ol√°, eu sou o CarsaiBot`"
            });
        }

        const text = args.join(' ');
        
        // Verificar se √© muito longo
        if (text.length > 200) {
            return await sock.sendMessage(jid, {
                text: "‚ùå Texto muito longo. M√°ximo 200 caracteres."
            });
        }

        try {
            await sock.sendMessage(jid, {
                text: "üîä Convertendo texto em √°udio..."
            });

            await this.sendAsVoice(sock, jid, text);
            
        } catch (error) {
            logger.error(`Erro no comando TTS: ${error.message}`);
            await sock.sendMessage(jid, {
                text: "‚ùå Erro ao converter texto em √°udio. Tente novamente."
            });
        }
    }
}

//module.exports = new TTSService();